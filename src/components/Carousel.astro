---
// ──────────────────────────────────────────────────────────────
//  Types & Props
// ──────────────────────────────────────────────────────────────
import type { ImageMetadata } from "astro";

interface Props {
  /** Array of images for the carousel */
  images: {
    /** Astro image metadata – we only need the `src` field */
    src: ImageMetadata;
    /** Alt text for the image (required for accessibility) */
    alt: string;
  }[];
}

const { images } = Astro.props;

// ──────────────────────────────────────────────────────────────
//  Unique ID – needed so multiple carousels on the same page don’t
//  clash when we query the DOM from the <script> block.
// ──────────────────────────────────────────────────────────────
const carouselId = `carousel-${Math.random().toString(36).slice(2, 11)}`;
---

<!-- ──────────────────────────────────────────────────────────────
     Carousel markup – all styling is done with Tailwind classes.
     The outer <section> gets the proper ARIA roles/labels.
   ────────────────────────────────────────────────────────────── -->
<section
  id={carouselId}
  class="relative overflow-hidden rounded-lg"
  role="region"
  aria-roledescription="carousel"
  aria-label="Image carousel"
  data-carousel-id={carouselId}
>
  <!-- Slides -->
  <div class="relative h-0 pb-[56.25%]">
    <!-- 16:9 ratio placeholder -->
    {
      images.map((image, i) => (
        <img
          src={image.src.src}
          alt={image.alt}
          class={`
          absolute inset-0 w-full h-full object-cover
          transition-opacity duration-500 ease-in-out
          ${i === 0 ? "opacity-100" : "opacity-0"}
          carousel-slide
        `}
          data-index={i}
        />
      ))
    }
  </div>

  <!-- Navigation Buttons -->
  <button
    type="button"
    class="absolute left-4 top-1/2 -translate-y-1/2
      flex h-10 w-10 items-center justify-center
      rounded-full bg-white/70 backdrop-blur-sm
      text-gray-800 hover:bg-white focus:outline-none
      focus-visible:ring-2 focus-visible:ring-indigo-600
      transition-colors"
    aria-label="Previous slide"
    data-dir="prev"
  >
    <!-- Heroicon: chevron‑left -->
    <svg
      class="h-5 w-5"
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="2"
      stroke="currentColor"
      aria-hidden="true"
    >
      <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7"
      ></path>
    </svg>
    <span class="sr-only">Previous</span>
  </button>

  <button
    type="button"
    class="absolute right-4 top-1/2 -translate-y-1/2
      flex h-10 w-10 items-center justify-center
      rounded-full bg-white/70 backdrop-blur-sm
      text-gray-800 hover:bg-white focus:outline-none
      focus-visible:ring-2 focus-visible:ring-indigo-600
      transition-colors"
    aria-label="Next slide"
    data-dir="next"
  >
    <!-- Heroicon: chevron‑right -->
    <svg
      class="h-5 w-5"
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="2"
      stroke="currentColor"
      aria-hidden="true"
    >
      <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"
      ></path>
    </svg>
    <span class="sr-only">Next</span>
  </button>

  <!-- Live region for screen‑reader announcements -->
  <div
    class="sr-only"
    aria-live="polite"
    aria-atomic="true"
    data-live-announcer
  >
  </div>
</section>

<!-- ──────────────────────────────────────────────────────────────
     Tailwind utilities are already available in the project.
     No extra CSS is required – everything lives in the classes above.
   ────────────────────────────────────────────────────────────── -->

<script define:vars={{ carouselId }}>
  // -----------------------------------------------------------------
  //  Carousel logic – runs once the component is in the DOM.
  // -----------------------------------------------------------------
  document.addEventListener("DOMContentLoaded", () => {
    const carousel = document.getElementById(carouselId);
    if (!carousel) return;

    const slides = carousel.querySelectorAll(".carousel-slide");
    const prevBtn = carousel.querySelector('[data-dir="prev"]');
    const nextBtn = carousel.querySelector('[data-dir="next"]');
    const liveAnnouncer = carousel.querySelector("[data-live-announcer]");

    let current = 0;
    const total = slides.length;
    let autoRotateTimer;

    // -----------------------------------------------------------------
    // Helper – show a slide by index (with fade transition)
    // -----------------------------------------------------------------
    const showSlide = (index) => {
      slides[current].classList.remove("opacity-100");
      slides[current].classList.add("opacity-0");

      current = index;

      slides[current].classList.remove("opacity-0");
      slides[current].classList.add("opacity-100");

      // Update screen‑reader announcement
      if (liveAnnouncer) {
        liveAnnouncerContent = `Slide ${current + 1} of ${total}`;
      }
    };

    // -----------------------------------------------------------------
    // Navigation button handlers
    // -----------------------------------------------------------------
    const goPrev = () => {
      const prev = (current - 1 + total) % total;
      showSlide(prev);
    };
    const goNext = () => {
      const next = (current + 1) % total;
      showSlide(next);
    };

    prevBtn?.addEventListener("click", goPrev);
    nextBtn?.addEventListener("click", goNext);

    // -----------------------------------------------------------------
    // Keyboard navigation (left / right arrows)
    // -----------------------------------------------------------------
    carousel.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft") {
        e.preventDefault();
        goPrev();
      } else if (e.key === "ArrowRight") {
        e.preventDefault();
        goNext();
      }
    });

    // -----------------------------------------------------------------
    // Auto‑rotate (pause on hover / focus)
    // -----------------------------------------------------------------
    const startAutoRotate = () => {
      stopAutoRotate(); // safety
      autoRotateTimer = window.setInterval(goNext, 5000);
    };
    const stopAutoRotate = () => {
      if (autoRotateTimer) {
        clearInterval(autoRotateTimer);
        autoRotateTimer = undefined;
      }
    };

    // Start rotating when the component mounts
    startAutoRotate();

    // Pause when the user hovers or focuses inside the carousel
    carousel.addEventListener("mouseenter", stopAutoRotate);
    carousel.addEventListener("mouseleave", startAutoRotate);
    carousel.addEventListener("focusin", stopAutoRotate);
    carousel.addEventListener("focusout", startAutoRotate);
  });
</script>
